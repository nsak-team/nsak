import logging
import subprocess
from pathlib import Path
from nsak.core.config import RUN_PATH

logger = logging.getLogger(__name__)

DEFAULT_DHCP = {
    "range_start": "10.0.0.10",
    "range_end": "10.0.0.200",
    "lease_time": "12h",
    "gateway": "10.0.0.1",
    "dns": "10.0.0.1",
    "upstream_dns": "1.1.1.1",
}


def run(interface: str) -> subprocess.Popen:
    """
    Generate a temporary dnsmasq DHCP configuration and start dnsmasq
    bound to the given interface.
    :param interface: ifc
    :return: subprocess.Popen
    """
    # runtime paths
    run_path = RUN_PATH / "dnsmasq"
    run_path.mkdir(parents=True, exist_ok=True)
    conf_path = run_path / "dnsmasq.conf"
    leases_path = run_path / "dnsmasq.leases"

    # Render minimal dnsmasq config; dhcp-leasefile stores assigned DHCP leases
    conf = "\n".join([
        "# generated by nsak dnsmasq drill",
        f"interface={interface}",
        # "bind-interfaces",
        f"dhcp-range={DEFAULT_DHCP['range_start']},{DEFAULT_DHCP['range_end']},{DEFAULT_DHCP['lease_time']}",
        f"dhcp-option=3,{DEFAULT_DHCP['gateway']}",
        f"dhcp-option=6,{DEFAULT_DHCP['dns']}",
        f"server={DEFAULT_DHCP['upstream_dns']}",
        f"dhcp-leasefile={leases_path}",
        "log-dhcp",
    ]) + "\n"

    conf_path.write_text(conf.strip() + "\n")
    logger.info("DHCP config written:\n%s", conf)
    logger.info("----------------------------------------------------")

    dnsmasq_bin_path = Path("/usr/sbin/dnsmasq")

    if not dnsmasq_bin_path.exists():
        raise RuntimeError("dnsmasq not found at /usr/sbin/dnsmasq")

    # start process
    return subprocess.Popen(
        [
            str(dnsmasq_bin_path),
            "-d",
            "-k",
            "-C", str(conf_path),
        ],
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
    )


def cleanup(proc: subprocess.Popen) -> None:
    """
    Terminate a running dnsmasq process gracefully and ensure it is reaped.

    :param proc: subprocess.Popen
    :return: None
    """
    # Check if the process has already exited to avoid sending signals to a dead process
    if proc.poll() is not None:
        return

    proc.terminate()
    try:
        proc.wait(timeout=2)  # wait for graceful shutdown and reap the process
    except subprocess.TimeoutExpired:
        proc.kill()   # last resort: forcefully terminate (SIGKILL)
        proc.wait(timeout=2) # ensure the killed process is reaped
