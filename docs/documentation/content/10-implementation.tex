In this chapter we will describe what and how we implemented the \acrshort{nsak} framework, the first two scenarios, their drills and environments.
To efficiently describe the implementation, we reference paths and files relative to the repositories root directory~\cite{nsakRepository2026}.
Additional technical information about the framework installation and development setup can be found in the \texttt{README.md}.


\section{\acrshort{nsak} framework}\label{sec:nsak_framework}

In this section we describe which technologies we choose to implement the \acrshort{nsak} framework and the resource library.

As this project is a so-called monorepo, the logical primary driver for the technology stack and dependencies is the core component.
The following system components such as the resource library and the \acrshort{cli} will inherit the technology stack, the python, and system dependencies.
For this reason, the components following the core will only describe what they introduce additionally.

\textbf{Core}\\
We did not make an extensive evaluation of which technologies are best suited for building developing the software and decided to use to go with tools that we like and are familiar with.
The location of the core in the GIT repository is under \texttt{src/nsak/core}, there are files for setup and configuration, a subfolder for network utilities and for each resource type.
All resource subfolders contain files for a dataclass representing the resource itself, a loader, and a manager class.


\begin{itemize}
    \item Programming language: Python~\cite{python}
    \item Dependency manager: uv~\cite{uv}
    \item Virtual environment manager: uv~\cite{uv}
    \item Package build tool: uv~\cite{uv}
    \item Linter: ruff~\cite{ruff}
    \item Formatter: ruff~\cite{ruff}
    \item Type checker: mypy~\cite{mypy}
    \item Testing framework: pytest~\cite{pytest}
\end{itemize}

\textbf{Python dependencies:}
\begin{itemize}
    \item pyyaml: Library for loading, validating, and reading YAML files~\cite{pyyaml},~\cite{yaml}
    \item scapy: Library for red team operations~\cite{scapy}
    \item pre-commit: Package to enforce code quality tools for each commit~\cite{precommit}
\end{itemize}

\textbf{System Dependencies}\\
As we leverage the abstraction of \acrshort{oci} containers to run scenarios in an encapsulated environment, we have only a minimal set of system dependencies.
All system dependencies that are required for running a drill or a scenario are installed into the scenario image, during the build process.

\begin{itemize}
    \item Version control: git~\cite{git}
    \item Network tooling: iptables, nftables~\cite{iptables},~\cite{nftables}
    \item \acrshort{oci} container manager: podman~\cite{podman}
    \item \acrshort{oci} container orchestrator: podman-compose~\cite{podman_compose}
    \item Programming languages: python3, pip, uv~\cite{python},~\cite{pip},~\cite{uv}
    \item Utilities: curl, sudo~\cite{curl},~\cite{sudo}
\end{itemize}

\textbf{Resource Library}\\
All resources included in the monorepo are located in their respective resource type subfolders under \texttt{lib/\{drills,scenarios,environments\}}.
This path can be adjusted with the environment variable \texttt{NSAK\_LIBRARY\_PATH} if a framework user or developer wants to load his own resource library.
In the additional \texttt{devices} subfolder are instructions to set up a specific \acrshort{nsak} device, currently this resource type is not implemented in the core and only contains one description for the Banana PI R4 as an example.
Resources with code implementations, namely scenarios and drills, manage their own python and system dependencies in their \acrshort{yaml} files.

\textbf{\acrshort{cli}}\\
The \acrshort{cli} frontend is located under \texttt{src/nsak/cli} with a file per-resource type, implementing and exposing the functionality to the user.
The steps required to enable autocompletion for some shells are described in the \texttt{README.md}.
Here is a list of common commands:
\begin{itemize}
    \item \texttt{nsak --help}: A description of all commands
    \item \texttt{nsak <resource-type> --help}: A description of the subcommand
    \item \texttt{nsak environment list}: Lists all described environment resources
    \item \texttt{nsak drill list}: Lists all implemented drills
    \item \texttt{nsak scenario list}: Lists all available scenarios
    \item \texttt{nsak scenario build <scenario-name>}: Build the \acrshort{oci} image for the scenario
    \item \texttt{nsak scenario run <scenario-name>}: Run a scenario as a \acrshort{oci} container
\end{itemize}

Python dependencies:
\begin{itemize}
    \item click: Library for building \gls{cli}s~\cite{click}
\end{itemize}


\section{\acrshort{mitm} (\acrshort{arp}-spoofing / transparent \acrshort{tcp} \gls{ProxyServer})}\label{sec:mitm_arp_spoofing_transparent_tcp_proxy}

\textbf{Network Topology / Environment}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{../assets/figures/diagrams/concept-architecture-diagrams/mitm_arp_spoofing_transparent_tcp_proxy}
    \caption{MITM scenarios in the simple TCP client server environment}
    \label{fig:mitm-arp-spoofing-transparent-tcp-proxy}
\end{figure}

\textbf{Figure~\ref{fig:mitm-arp-spoofing-transparent-tcp-proxy}} illustrates the network topology used for the \acrfull{mitm} scenario.
It consists of two dotted circles separating the network boundaries of two networks.
The left circle is describing a simple \acrshort{tcp} client - server environment consisting of Alice (client), Bob (server), a network switch, and the \acrshort{nsak} device which was placed in the target network.
The right circle is sketching the management network, which is used by a red team operator to remotely execute the \acrshort{mitm} scenario on the \acrshort{nsak} device.

\textbf{\acrshort{mitm} scenario implementation}\\
This section describes the implementation and simulation of the \acrshort{mitm} scenario.
It represents a classic \acrshort{tcp} \acrfull{mitm} attack, where traffic is intercepted with \acrshort{arp} poisoning and a transparent \acrshort{tcp} \gls{ProxyServer}.
After an initial network discovery phase, the scenario creates a transparent \gls{ProxyServer} by starting a \acrshort{tcp} client and \acrshort{tcp} server and redirecting traffic.
Then it's time to use \acrshort{mac} Address spoofing to convince all other network participants that they should send all packets to the \acrshort{nsak} device.
If everything worked correctly, the \acrshort{nsak} device is able to read, modify, or drop packets sent from one participant to another.

I choose the following separation of the scenario, which describes the drills, which have to be implemented:
\begin{itemize}
    \item Network Hosts Discovery: \texttt{lib/drills/discover\_hosts}
    \item Transparent \acrshort{tcp} \gls{ProxyServer}: \texttt{lib/drills/transparent\_tcp\_proxy}
    \item \acrshort{arp}-spoof: \texttt{lib/drills/arp\_spoof}
\end{itemize}

\textbf{Drills}\\
The \textbf{Discover Host Drill} iterates over all target network interfaces and uses \acrshort{arp}-scan to collect a list of all hosts in all subnets.
While this approach is certainly good enough for the PoC, it could possibly take a lot of time and yield huge lists of hosts.
So it would make sense to provide further configration options such as subnet filters or limits.
In the context of this drill, a new dataclass \texttt{NetworkDiscoveryResultMap} was added to the core to provide a common interface for similar network discovery drills and drills requiring such results.
The drill then returns an instance of the \texttt{NetworkDiscoveryResultMap} dataclass.\\~\\
The \textbf{Transparent \acrshort{tcp} \gls{ProxyServer}} requires a \texttt{NetworkDiscoveryResultMap} instance, e.g., generated with the host discovery drill.
It starts a transparent \acrshort{tcp} proxy for each client - server connection in the \texttt{NetworkDiscoveryResultMap} and sets up the necessary target network configuration with iptables.
Then the drill reads and modifies the intercepted traffic, which is the goal of a \acrshort{mitm} attack.
The packet manipulation is currently only a simple string replacement, it would be a nice future work to make it possible to specify a custom payload.
Maybe it could make sense to split up this drill even further, as maybe as \acrshort{tcp} client, server, or the network interface configration could be reused in other drills.
The \textbf{\acrshort{arp}-spoof Drill} also requires a \texttt{NetworkDiscoveryResultMap} instance, which provides target network interfaces and subnets to iterate over.
It then uses the \enquote{arpspoof} command to poison the \acrshort{arp} tables of all target hosts.

\textbf{Simple \acrshort{tcp} client - server environment}\\
For development and testing purposes the simple \acrshort{tcp} client - server environment was added as a resource to the \acrshort{nsak} repository.
The resource includes a virtualized lab setup with a podman/docker compose file and provides an extensive readme file, describing the setup of this environment as a physical lab environment.

This physical lab setup builds the basis for the experiment, verifying that the \acrshort{mitm} scenario works in a real-world environment.
The compose file provides a possible representation of the target network with containers acting as Alice and Bob.
The containers entrypoints are two Python scripts, which are implementing the behavior as a \acrshort{tcp} client for Alice and as a \acrshort{tcp} server for Bob.
Because the default network driver used by podman and docker compose is abstracting away the data link of the OSI model,
the configuration of the macvlan network driver is required to simulate the network behavior on layer 2 correctly.
The \acrshort{mitm} scenario resource contains a subfolder containing another readme file, describing its integration in this physical lab environment.
A video demonstrating this physical setup in a real-world experiment can be found in this repository.
This subfolder also provides a podman/docker compose file which extends the compose file of this resource, providing a complete setup for running the scenario in a simulation.
The containerized simulation can be executed with~\texttt{nsak environment simulate simple\_tcp\_client\_server mitm}.
The \acrshort{nsak} framework was then extended with the ability to simulate a scenario in a compatible environment which provides a podman/docker compose implementation.

References:
\begin{itemize}
    \item {
        Simple \acrshort{tcp} Client - Server Environment:
        \begin{itemize}
            \item Folder: \texttt{lib/environments/simple\_tcp\_client\_server}
            \item Podman compose file: \texttt{simple\_tcp\_client\_server/compose.yaml}
            \item Readme file: \texttt{simple\_tcp\_client\_server/README.md}
        \end{itemize}
    }
    \item {
        \acrshort{mitm} Scenario in the Smiple \acrshort{tcp} Client - Server Environment:
        \begin{itemize}
            \item Subfolder: \texttt{lib/scenarios/mitm/environments/simple\_tcp\_client\_server/}
            \item Podman compose file: \texttt{simple\_tcp\_client\_server/compose.yaml}
            \item Readme file: \texttt{simple\_tcp\_client\_server/README.md}
        \end{itemize}
    }
    \item Demo video: \texttt{docs/presentation/assets/nsak\_mitm\_scenario.mp4}
\end{itemize}


\section{Rogue Access Point}\label{sec: Rogue Access Point}\gls{rogueap}

\textbf{Network Topology}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{../assets/figures/diagrams/concept-architecture-diagrams/rogue-ap}
    \caption{Network set up RAP}
    \label{fig:rogue-ap}
\end{figure}

Figure~\ref{fig:rogue-ap} illustrates the network topology used for the Rogue Access Point scenario.
The NSAK device is positioned between the wireless clients and an upstream host system acting as an internet gateway.
Two network interfaces are used on the NSAK device: a wireless interface (wlan0) operating in access point mode,
and a wired uplink interface (eth1) connected to the host system.

\textbf{Rogue Access Point Implementation}
This section describes the technical realization of the Rogue Access Point scenario within the NSAK framework.
The focus lies on the integration of wireless access point functionality, traffic forwarding,
and packet capture.


Within the NSAK framework, the Rogue Access Point scenario is implemented as a composition of multiple drills.
Each drill encapsulates a single operational responsibility, allowing the scenario to orchestrate the drills separately,
ant to remain modular and extensible.

\textbf{Scenario}
The Rogue Access Point scenario consists of several drills that are executed sequentially to establish a functional
wireless access point capable of intercepting and forwarding network traffic.

\begin{itemize}
    \item Network interface preparation
    \item Wireless access point initialization
    \item Traffic forwarding and network address translation
    \item Packet capture and monitoring
\end{itemize}

\textbf{Drills}


\textbf{The Hostapd Drill} is responsible for configuring the wireless network interface of the NSAK device in access
mode.
This includes assigning network parameters to the interfaces and enabling beacon transmission to allow the client
devices to connect to the rogue access point


The access point functionality is implemented using standard Linux networking services running in an isolated subprocesses.
The controlled interaction with the operating system allows reliable startup and shutdown behavior.
Furthermore, the current process state can be tracked.


\textbf{Traffic Forwarding and Network Integration drills} are providing network connectivity for clients.
The NSAK device establishes an uplink connection to an external network interface.
Traffic forwarding is enabled between the wireless and uplink interfaces, enabling transparent internet access.


Network address translation and packet forwarding are configured dynamically during scenario execution.
This enables the NSAK device to operate as an intermediary between wireless clients and the upstream network.


In parallel, a \textbf{traffic capture drill} on the connected interface captures traffic passing through.
The pcap files can be used for later analysis, enabling the evaluation of client behavior and the network.
interactions.

By separating packet capture into an independent drill, the framework allows traffic monitoring to
be reused across different scenarios without modification.

The scenario manager orchestrates the execution of all drills involved in the Rogue Access Point scenario.
Drills are executed in a predefined order, ensuring that the required network services are available before
dependent components are started.


\textbf{Error handling and cleanup}\\
To prevent persistent system modifications, each drill defines a cleanup routine that can be executed after scenario
completion or upon failure.
This ensures that network interfaces and system services are restored to their original state.
In the current state of the POC the cleanup functionality need to be adjusted for the broad diversity of the drills
and covers momentarily not all possible edge cases.

But as mentioned in, a centralized cleanup mechanism ensures that partial execution states do not persist in the system
in an inconsistent configuration.
And helps to prevent uncontrolled behaviors of drills.

\textbf{}
This section focused on the technical realization of the Rogue Access Point scenario.
The effectiveness and behavior of the scenario under real network conditions are evaluated in the subsequent evaluation
chapter.
